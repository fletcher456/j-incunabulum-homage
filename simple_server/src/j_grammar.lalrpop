use crate::j_array::JArray;
use crate::parser::JNode;
use crate::tokenizer::Token;

grammar;

pub JExpression: JNode = {
    Expression,
};

Expression: JNode = {
    DyadicExpr,
    MonadicExpr,
    Term,
};

DyadicExpr: JNode = {
    <left:MonadicExpr> <verb:Verb> <right:Expression> => {
        JNode::AmbiguousVerb(verb, Some(Box::new(left)), Some(Box::new(right)))
    },
    <left:Term> <verb:Verb> <right:Expression> => {
        JNode::AmbiguousVerb(verb, Some(Box::new(left)), Some(Box::new(right)))
    },
};

MonadicExpr: JNode = {
    <verb:Verb> <expr:Term> => {
        JNode::AmbiguousVerb(verb, None, Some(Box::new(expr)))
    },
};

Term: JNode = {
    Vector => JNode::Literal(<>),
    "(" <Expression> ")",
};

// Unified verb definition
Verb: char = {
    "+" => '+',
    "~" => '~',
    "#" => '#',
    "<" => '<',
    "{" => '{',
    "," => ',',
};

// Token conversion rules
Vector: JArray = {
    <t:VectorToken> => t,
};

extern {
    type Location = usize;
    type Error = String;
    
    enum Token {
        VectorToken => Token::Vector(<JArray>),
        "+" => Token::Verb('+'),
        "~" => Token::Verb('~'),
        "#" => Token::Verb('#'),
        "<" => Token::Verb('<'),
        "{" => Token::Verb('{'),
        "," => Token::Verb(','),
        "(" => Token::LeftParen,
        ")" => Token::RightParen,
    }
}