use crate::j_array::JArray;
use crate::parser::JNode;
use crate::tokenizer::Token;

grammar;

pub JExpression: JNode = {
    Expression,
};

Expression: JNode = {
    DyadicLevel,
};

// Right-associative dyadic operators (lower precedence)
DyadicLevel: JNode = {
    <left:MonadicLevel> <verb:Verb> <right:DyadicLevel> => {
        JNode::AmbiguousVerb(verb, Some(Box::new(left)), Some(Box::new(right)))
    },
    MonadicLevel,
};

// Left-associative monadic operators (higher precedence)
MonadicLevel: JNode = {
    <verb:Verb> <right:MonadicLevel> => {
        JNode::AmbiguousVerb(verb, None, Some(Box::new(right)))
    },
    Atom,
};

Atom: JNode = {
    Vector => JNode::Literal(<>),
    "(" <Expression> ")",
};



// Unified verb definition
Verb: char = {
    "+" => '+',
    "~" => '~',
    "#" => '#',
    "<" => '<',
    "{" => '{',
    "," => ',',
};

// Token conversion rules
Vector: JArray = {
    <t:VectorToken> => t,
};

extern {
    type Location = usize;
    type Error = String;
    
    enum Token {
        VectorToken => Token::Vector(<JArray>),
        "+" => Token::Verb('+'),
        "~" => Token::Verb('~'),
        "#" => Token::Verb('#'),
        "<" => Token::Verb('<'),
        "{" => Token::Verb('{'),
        "," => Token::Verb(','),
        "(" => Token::LeftParen,
        ")" => Token::RightParen,
    }
}